struct Functions{
  float2x2 rotate(float r) {
      float c = cos(r);
      float s = sin(r);
      return float2x2(c, -s, s, c);
  }
  float2 rand2(float2 p)
  {
  	float2 q = float2(dot(p,float2(127.1,311.7)),
  		dot(p,float2(269.5,183.3)));
  	return frac(sin(q)*43758.5453);
  }

  float rand(float2 p)
  {
  	return frac(sin(dot(p,float2(419.2,371.9))) * 833458.57832);
  }

  float iqnoise(in float2 pos, float irregular, float smoothness)
  {
  	float2 cell = floor(pos);
  	float2 cellOffset = frac(pos);

  	float sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);

  	float value = 0.0;
  	float accum = 0.0;
  	// Sample the surrounding cells, from -2 to +2
  	// This is necessary for the smoothing as well as the irregular grid.
  	for(int x=-2; x<=2; x++ )
  	for(int y=-2; y<=2; y++ )
  	{
  		float2 samplePos = float2(float(y), float(x));

    		// Center of the cell is not at the center of the block for irregular noise.
    		// Note that all the coordinates are in "block"-space, 0 is the current block, 1 is one block further, etc
  		float2 center = rand2(cell + samplePos) * irregular;
  		float centerDistance = length(samplePos - cellOffset + center);

  		// High sharpness = Only extreme values = Hard borders = 64
  		// Low sharpness = No extreme values = Soft borders = 1
  		float sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);

  		// A different "color" (shade of gray) for each cell
  		float color = rand(cell + samplePos);
  		value += color * sam;
  		accum += sam;
  	}

  	return value/accum;
  }
};

Functions f;
uv*=2.;
float2 fv = uv;
uv-=.5;
float id = f.rand(floor(fv));
fv=frac(fv)-.5;
fv*=2.;
float2 gv = fv;
gv = mul(f.rotate(3.1415/5.),gv);

float col = smoothstep(clamp(id,.4,.8),clamp(id-.1,.3,.7),length(gv+(f.iqnoise(gv*100.,1.,1.)-.5)*.5))*sin((gv.x-f.iqnoise(gv*10.,1.,1.)*.05)*100.);
fv = mul(f.rotate(-3.1415/5.),fv);
col = max(col,smoothstep(.8,.6,length(fv+(f.iqnoise(fv*100.,1.,1.)-.5)*.5))*sin((fv.x-f.iqnoise(fv*10.,1.,1.)*.05)*100.));

uv.x/=1.2;
id = f.rand(floor(uv));
uv=frac(uv)-.5;
uv*=2.;
gv = uv;
gv = mul(f.rotate(3.1415/5.),gv);

col += smoothstep(id,id-.1,length(gv+(f.iqnoise(gv*100.,1.,1.)-.5)*.5))*sin((gv.x-f.iqnoise(gv*10.,1.,1.)*.05)*100.);
uv = mul(f.rotate(-3.1415/5.),uv);
col = max(col,smoothstep(.8,.6,length(uv+(f.iqnoise(uv*100.,1.,1.)-.5)*.5))*sin((uv.x-f.iqnoise(uv*10.,1.,1.)*.05)*100.));

return col;
